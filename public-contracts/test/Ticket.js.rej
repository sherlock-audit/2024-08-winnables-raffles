diff a/public-contracts/test/Ticket.js b/public-contracts/test/Ticket.js	(rejected hunks)
@@ -1,29 +1,32 @@
 const { ethers } = require('hardhat');
 const { expect } = require('chai');
-const helpers = require('@nomicfoundation/hardhat-network-helpers');
+const { oneHundredLink, formatBytes } = require('./common/chainlink');
 
-const {
-  getWalletWithEthers, blockTime, timeSeconds,
-} = require('./common/utils');
-const { ccipDeployTicketManager } = require('../utils/demo');
 const { whileImpersonating } = require('../utils/impersonate');
-const { BigNumber } = require('ethers');
-const {sign} = require('node:crypto');
+const helpers = require('@nomicfoundation/hardhat-network-helpers');
 
 ethers.utils.Logger.setLogLevel(ethers.utils.Logger.levels.ERROR);
 
-describe('CCIP Ticket Manager', () => {
+describe('Winnables Tickets', () => {
   let signers;
   let manager;
   let ticket;
-  let winnablesDeployer;
+  let link;
+  let snapshot;
 
   before(async () => {
     signers = await ethers.getSigners();
-    const result = await ccipDeployTicketManager();
-    winnablesDeployer = signers[0];
-    manager = result.ticketManager;
-    ticket = result.ticket;
+    const linkFactory = await ethers.getContractFactory('MockLink');
+    link = await linkFactory.deploy();
+    await link.deployed();
+
+    await link.mint(signers[0].address, oneHundredLink.mul(10));
+
+    const TicketFactory = await ethers.getContractFactory(
+      'WinnablesTicket',
+    );
+    ticket = await TicketFactory.deploy();
+    await ticket.deployed();
   });
 
   describe('Initializes correctly', () => {
@@ -44,7 +47,7 @@ describe('CCIP Ticket Manager', () => {
         supportsERC165,
         supportsRandomStuff,
       ] = await Promise.all([
-        ticket.supportsInterface('0x9141187b'),
+        ticket.supportsInterface('0xefa07c25'),
         ticket.supportsInterface('0xd9b67a26'),
         ticket.supportsInterface('0x0e89341c'),
         ticket.supportsInterface('0x01ffc9a7'),
@@ -59,6 +62,63 @@ describe('CCIP Ticket Manager', () => {
   });
 
   describe('Ticket behaviour', () => {
+    before(async () => {
+      snapshot = await helpers.takeSnapshot();
+    });
+
+    after(async () => {
+      await snapshot.restore();
+    });
+
+    it('Doesn\'t accept manager deployed by non-owner', async () => {
+      const WinnablesTicketManagerFactory = await ethers.getContractFactory(
+        'WinnablesTicketManager',
+        signers[3],
+      );
+      const tx = WinnablesTicketManagerFactory.deploy(
+        link.address,
+        link.address,
+        0,
+        ethers.constants.HashZero,
+        ticket.address,
+        ticket.address
+      );
+      await expect(tx).to.be.revertedWithCustomError(ticket, 'NotOwnerOrigin');
+    });
+
+    it('Accept manager deployed by owner', async () => {
+      const WinnablesTicketManagerFactory = await ethers.getContractFactory(
+        'WinnablesTicketManager',
+      );
+      manager = await WinnablesTicketManagerFactory.deploy(
+        link.address,
+        link.address,
+        0,
+        ethers.constants.HashZero,
+        ticket.address,
+        ticket.address
+      );
+      await manager.deployed();
+
+      await (await manager.setRole(signers[0].address, 1, true)).wait();
+      await (await manager.setRole(signers[1].address, 1, true)).wait();
+    });
+
+    it('Cannot initialize twice', async () => {
+      const WinnablesTicketManagerFactory = await ethers.getContractFactory(
+        'WinnablesTicketManager',
+      );
+      const tx = WinnablesTicketManagerFactory.deploy(
+        link.address,
+        link.address,
+        0,
+        ethers.constants.HashZero,
+        ticket.address,
+        ticket.address
+      );
+      await expect(tx).to.be.revertedWithCustomError(ticket, 'AlreadyInitialized');
+    });
+
     it('Doesn\'t support batch mint', async () => {
       await expect(ticket.batchMint(signers[0].address, [1], [1])).to.be.revertedWithCustomError(
         ticket,
@@ -66,17 +126,18 @@ describe('CCIP Ticket Manager', () => {
       );
     });
 
-    it('Doesn\'t mint to address zero', async () => {
-      await (await ticket.setRole(signers[0].address, 1, true)).wait();
+    it('Doesn\'t mint except if called by the manager', async () => {
       await expect(ticket.mint(ethers.constants.AddressZero, 1, 1)).to.be.revertedWithCustomError(
         ticket,
-        'TransferToAddressZero'
+        'NotTicketManager'
       );
     });
 
     it('Mints tickets to regular address', async () => {
-      await (await ticket.setRole(signers[0].address, 1, true)).wait();
-      const { events } = await (await ticket.mint(signers[1].address, 1, 1)).wait();
+      const tx = await whileImpersonating(manager.address, ethers.provider, async (signer) =>
+        ticket.connect(signer).mint(signers[1].address, 1, 1)
+      );
+      const { events } = await tx.wait();
       expect(events).to.have.lengthOf(2);
       expect(events[0].event).to.eq('NewTicket');
       expect(events[1].event).to.eq('TransferSingle');
@@ -139,6 +200,24 @@ describe('CCIP Ticket Manager', () => {
   });
 
   describe('Ownership and admin functions', () => {
+    before(async () => {
+      const WinnablesTicketManagerFactory = await ethers.getContractFactory(
+        'WinnablesTicketManager',
+      );
+      manager = await WinnablesTicketManagerFactory.deploy(
+        link.address,
+        link.address,
+        0,
+        ethers.constants.HashZero,
+        ticket.address,
+        ticket.address
+      );
+      await manager.deployed();
+
+      await (await manager.setRole(signers[0].address, 1, true)).wait();
+      await (await manager.setRole(signers[1].address, 1, true)).wait();
+    });
+
     it('Transfers ownership', async () => {
       const { events } = await (await ticket.transferOwnership(signers[1].address)).wait();
       expect(events).to.have.lengthOf(1);
