diff a/public-contracts/test/PrizeManager.js b/public-contracts/test/PrizeManager.js	(rejected hunks)
@@ -4,10 +4,9 @@ const helpers = require('@nomicfoundation/hardhat-network-helpers');
 const {
   getWalletWithEthers,
 } = require('./common/utils');
-const { ccipDeployPrizeManager} = require('../utils/demo');
+const { ccipDeployPrizeManager } = require('../utils/demo');
 const { whileImpersonating } = require('../utils/impersonate');
-const exp = require('node:constants');
-const {BigNumber} = require('ethers');
+const { BigNumber } = require('ethers');
 
 ethers.utils.Logger.setLogLevel(ethers.utils.Logger.levels.ERROR);
 
@@ -19,9 +18,9 @@ describe('CCIP Prize Manager', () => {
   let winnablesDeployer;
   let nft;
   let token;
-  let api;
   let snapshot;
   let counterpartContractAddress;
+  let usdt
 
   before(async () => {
     signers = await ethers.getSigners();
@@ -33,6 +32,9 @@ describe('CCIP Prize Manager', () => {
     token = result.token;
     ccipRouter = result.ccipRouter;
     counterpartContractAddress = signers[1].address;
+    const USDTFactory = await ethers.getContractFactory("TetherToken");
+    usdt = await USDTFactory.deploy()
+    await usdt.deployed();
   });
 
   it('Should not be able to lock a prize if not admin', async () => {
@@ -61,9 +63,25 @@ describe('CCIP Prize Manager', () => {
     )).to.be.revertedWithCustomError(manager, 'MissingRole');
   });
 
-  it('Should not be able to lock a NFT prize before sending it', async () => {
+  it('Should not be able to set CCIP Extra Args as non-admin', async () => {
+    const randomUser = signers[10];
+
+    await expect(manager.connect(randomUser).setCCIPExtraArgs("0xff00")).to.be.revertedWithCustomError(
+      manager,
+      'MissingRole'
+    );
+  });
+
+  it('Should be able to set CCIP Extra Args as admin', async () => {
+    await manager.setCCIPExtraArgs("0x00ff");
+  });
+
+  it('Mint an NFT for locking', async () => {
     await (await nft.mint(signers[0].address)).wait();
-    await expect(manager.connect(winnablesDeployer).lockNFT(
+  })
+
+  it('Should not be able to lock a NFT prize before sending it', async () => {
+    await expect(manager.lockNFT(
       counterpartContractAddress,
       1,
       1,
@@ -73,7 +91,7 @@ describe('CCIP Prize Manager', () => {
   });
 
   it('Should not be able to lock a ETH prize without sending it', async () => {
-    await expect(manager.connect(winnablesDeployer).lockETH(
+    await expect(manager.lockETH(
       counterpartContractAddress,
       1,
       2,
@@ -82,7 +100,7 @@ describe('CCIP Prize Manager', () => {
   });
 
   it('Should not be able to lock a Token prize without sending it', async () => {
-    await expect(manager.connect(winnablesDeployer).lockTokens(
+    await expect(manager.lockTokens(
       counterpartContractAddress,
       1,
       1,
@@ -91,9 +109,32 @@ describe('CCIP Prize Manager', () => {
     )).to.be.revertedWithCustomError(manager, 'InvalidPrize');
   });
 
-  it('Cannot lock prize with insufficient LINK balance', async () => {
+  it('Transfers the NFT Prize for locking', async () => {
     await (await nft.transferFrom(signers[0].address, manager.address, 1)).wait();
-    await expect(manager.connect(winnablesDeployer).lockNFT(
+  })
+
+  it('Should not be able to lock a NFT prize to Zero address', async () => {
+    await expect(manager.lockNFT(
+      ethers.constants.AddressZero,
+      1,
+      1,
+      nft.address,
+      1
+    )).to.be.revertedWithCustomError(manager, 'MissingCCIPParams');
+  });
+
+  it('Should not be able to lock a NFT prize to Zero chain', async () => {
+    await expect(manager.lockNFT(
+      counterpartContractAddress,
+      0,
+      1,
+      nft.address,
+      1
+    )).to.be.revertedWithCustomError(manager, 'MissingCCIPParams');
+  });
+
+  it('Cannot lock prize with insufficient LINK balance', async () => {
+    await expect(manager.lockNFT(
       counterpartContractAddress,
       1,
       1,
@@ -102,6 +143,34 @@ describe('CCIP Prize Manager', () => {
     )).to.be.revertedWithCustomError(manager, 'InsufficientLinkBalance');
   });
 
+  it('Should not be able to lock LINK as token prize', async () => {
+    const linkAmount = ethers.utils.parseEther('1');
+    await (await link.mint(manager.address, linkAmount)).wait();
+
+    await expect(manager.lockTokens(
+      counterpartContractAddress,
+      1,
+      1,
+      link.address,
+      100
+    )).to.be.revertedWithCustomError(manager, 'LINKTokenNotPermitted');
+
+    await (await manager.withdrawToken(link.address, linkAmount)).wait();
+  });
+
+  it('Can receive NFT using safeTransferFrom', async () => {
+    const safeTransferFrom = 'safeTransferFrom(address,address,uint256)';
+
+    await (await nft.mint(signers[0].address)).wait();
+    await (await link.mint(manager.address, ethers.utils.parseEther('100'))).wait();
+
+    const tx = await nft.connect(signers[0])[safeTransferFrom](signers[0].address, manager.address, 2);
+    const { events } = await tx.wait();
+
+    const transferFevent = nft.interface.parseLog(events[0]);
+    expect(transferFevent.name).to.eq('Transfer');
+  });
+
   it('Cannot create Raffle #0', async () => {
     const tx = manager.lockNFT(
       counterpartContractAddress,
@@ -114,8 +183,8 @@ describe('CCIP Prize Manager', () => {
   });
 
   it('Should be able to lock NFT prize with enough LINK', async () => {
-    await (await link.connect(signers[0]).mint(manager.address, ethers.utils.parseEther('100'))).wait();
-    const tx = await manager.connect(winnablesDeployer).lockNFT(
+    await (await link.mint(manager.address, ethers.utils.parseEther('100'))).wait();
+    const tx = await manager.lockNFT(
       counterpartContractAddress,
       1,
       1,
@@ -137,8 +206,8 @@ describe('CCIP Prize Manager', () => {
   });
 
   it('Should not be able to lock ETH prize with existing raffle ID', async () => {
-    await (await link.connect(signers[0]).mint(manager.address, ethers.utils.parseEther('100'))).wait();
-    const tx = manager.connect(winnablesDeployer).lockETH(
+    await (await link.mint(manager.address, ethers.utils.parseEther('100'))).wait();
+    const tx = manager.lockETH(
       counterpartContractAddress,
       1,
       1,
@@ -151,8 +220,8 @@ describe('CCIP Prize Manager', () => {
   });
 
   it('Should be able to lock ETH prize with enough LINK', async () => {
-    await (await link.connect(signers[0]).mint(manager.address, ethers.utils.parseEther('100'))).wait();
-    const tx = await manager.connect(winnablesDeployer).lockETH(
+    await (await link.mint(manager.address, ethers.utils.parseEther('100'))).wait();
+    const tx = await manager.lockETH(
       counterpartContractAddress,
       1,
       2,
@@ -174,11 +243,26 @@ describe('CCIP Prize Manager', () => {
     expect(prize.winner).to.eq(ethers.constants.AddressZero);
   });
 
+  it('Lock USDT for Raffle #4', async () => {
+    await (await usdt.transfer(manager.address, 100)).wait();
+    const tx = await manager.lockTokens(
+      counterpartContractAddress,
+      1,
+      4,
+      usdt.address,
+      100
+    );
+    await tx.wait();
+    const tokenInfo = await manager.getTokenRaffle(4);
+    expect(tokenInfo.tokenAddress).to.eq(usdt.address);
+    expect(tokenInfo.amount).to.eq(100);
+  });
+
   it('Should be able to lock Tokens prize with enough LINK', async () => {
-    await (await link.connect(winnablesDeployer).mint(manager.address, ethers.utils.parseEther('100'))).wait();
-    await (await token.connect(winnablesDeployer).mint(winnablesDeployer.address, 100)).wait();
+    await (await link.mint(manager.address, ethers.utils.parseEther('100'))).wait();
+    await (await token.mint(winnablesDeployer.address, 100)).wait();
     await (await token.transfer(manager.address, 100)).wait();
-    const tx = await manager.connect(winnablesDeployer).lockTokens(
+    const tx = await manager.lockTokens(
       counterpartContractAddress,
       1,
       3,
@@ -214,7 +298,7 @@ describe('CCIP Prize Manager', () => {
     const tx = manager.lockNFT(
       counterpartContractAddress,
       1,
-      4,
+      5,
       nft.address,
       1
     );
@@ -229,16 +313,7 @@ describe('CCIP Prize Manager', () => {
       await snapshot.restore();
     });
 
-    it('Cannot set CCIP Counterpart as a non-admin', async () => {
-      await expect(manager.connect(signers[1]).setCCIPCounterpart(
-        counterpartContractAddress,
-        1,
-        true
-      )).to.be.revertedWithCustomError(manager, 'MissingRole')
-    })
-
     it('Cannot cancel non-existing raffle', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -250,18 +325,26 @@ describe('CCIP Prize Manager', () => {
       );
       await expect(tx).to.be.revertedWithCustomError(
         manager,
-        'InvalidRaffle'
+        'UnauthorizedCCIPSender'
       );
     });
-  });
 
-  describe('Attempts to cancel the raffle and withdraw the NFT', () => {
-    before(async () => {
-      snapshot = await helpers.takeSnapshot();
-    });
-    after(async () => {
-      await snapshot.restore();
+    it('Cannot declare a winner for a non-existing raffle', async () => {
+      const tx = whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
+        manager.connect(signer).ccipReceive({
+          messageId: ethers.constants.HashZero,
+          sourceChainSelector: 1,
+          sender: '0x' + counterpartContractAddress.slice(-40).padStart(64, '0'),
+          data: '0x010000000000000000000000000000000000000000000000000000000000000005',
+          destTokenAmounts: []
+        })
+      );
+      await expect(tx).to.be.revertedWithCustomError(
+        manager,
+        'UnauthorizedCCIPSender'
+      );
     });
+
     it('Can\'t withdraw the prize', async () => {
       await expect(manager.withdrawNFT(nft.address, 1))
         .to.be.revertedWithCustomError(manager, 'NFTLocked');
@@ -278,11 +361,12 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Can\'t unlock the prize from an unauthorized sender', async () => {
+      const unauthorizedSender = await getWalletWithEthers();
       const tx = whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
           sourceChainSelector: 1,
-          sender: '0x' + counterpartContractAddress.slice(-40).padStart(64, '0'),
+          sender: '0x' + unauthorizedSender.address.slice(-40).padStart(64, '0'),
           data: '0x000000000000000000000000000000000000000000000000000000000000000001',
           destTokenAmounts: []
         })
@@ -291,7 +375,6 @@ describe('CCIP Prize Manager', () => {
     })
 
     it('Can unlock the tokens with a cancel message', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -374,11 +457,12 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Can\'t unlock the prize from an unauthorized sender', async () => {
+      const unauthorizedSender = await getWalletWithEthers();
       const tx = whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
           sourceChainSelector: 1,
-          sender: '0x' + counterpartContractAddress.slice(-40).padStart(64, '0'),
+          sender: '0x' + unauthorizedSender.address.slice(-40).padStart(64, '0'),
           data: '0x000000000000000000000000000000000000000000000000000000000000000002',
           destTokenAmounts: []
         })
@@ -387,7 +471,6 @@ describe('CCIP Prize Manager', () => {
     })
 
     it('Can unlock the prize with a cancel message', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -459,11 +542,12 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Can\'t unlock the prize from an unauthorized sender', async () => {
+      const unauthorizedSender = await getWalletWithEthers();
       const tx = whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
           sourceChainSelector: 1,
-          sender: '0x' + counterpartContractAddress.slice(-40).padStart(64, '0'),
+          sender: '0x' + unauthorizedSender.address.slice(-40).padStart(64, '0'),
           data: '0x000000000000000000000000000000000000000000000000000000000000000003',
           destTokenAmounts: []
         })
@@ -472,7 +556,6 @@ describe('CCIP Prize Manager', () => {
     })
 
     it('Can unlock the tokens with a cancel message', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -487,6 +570,11 @@ describe('CCIP Prize Manager', () => {
       expect(events[0].event).to.eq('PrizeUnlocked');
     });
 
+    it('Can not withdraw the tokens with withdrawNFT', async () => {
+      await expect(manager.withdrawNFT(token.address, 1))
+        .to.be.revertedWithCustomError(manager, 'NotAnNFT');
+    });
+
     it('Can withdraw the Tokens now', async () => {
       const tx = await manager.withdrawToken(token.address, 100);
       const { events } = await tx.wait();
@@ -517,7 +651,6 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Can unlock the prize with a WinnerDrawn message', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -567,7 +700,6 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Can unlock the prize with a WinnerDrawn message', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -614,7 +746,6 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Unlocks the prize with a WinnerDrawn message', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -659,7 +790,6 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Can unlock the prize with a WinnerDrawn message', async () => {
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
         manager.connect(signer).ccipReceive({
           messageId: ethers.constants.HashZero,
@@ -710,11 +890,14 @@ describe('CCIP Prize Manager', () => {
       await snapshot.restore();
     });
 
+    it('Fund with LINK', async () => {
+      await (await link.mint(manager.address, ethers.utils.parseEther('100'))).wait();
+    });
+
     it('Create 2 raffles', async () => {
       const value = BigNumber.from(10).pow(18);
-      await (await manager.setCCIPCounterpart(counterpartContractAddress, 1, true)).wait();
       {
-        const tx = await manager.connect(winnablesDeployer).lockETH(
+        const tx = await manager.lockETH(
           counterpartContractAddress,
           1,
           100,
@@ -726,7 +909,7 @@ describe('CCIP Prize Manager', () => {
         await tx.wait();
       }
       {
-        const tx = await manager.connect(winnablesDeployer).lockETH(
+        const tx = await manager.lockETH(
           counterpartContractAddress,
           1,
           101,
@@ -772,11 +955,103 @@ describe('CCIP Prize Manager', () => {
     });
 
     it('Claims twice as Winner A', async () => {
-        const tx = await manager.connect(winnerA).claimPrize(100);
+      const tx = await manager.connect(winnerA).claimPrize(100);
+      await tx.wait();
+      await expect(manager.connect(winnerA).claimPrize(100)).to.be.revertedWithCustomError(
+        manager, 'AlreadyClaimed'
+      );
+    });
+
+    it('Claim as winner B', async () => {
+      {
+        const tx = await manager.connect(winnerB).claimPrize(101);
         await tx.wait();
-        await expect(manager.connect(winnerA).claimPrize(100)).to.be.revertedWithCustomError(
-          manager, 'AlreadyClaimed'
+      }
+    });
+  });
+
+  describe('Re-entrant Double-claim prize (ETH)', () => {
+    let winnerA;
+    let winnerB;
+    before(async () => {
+      const factory = await ethers.getContractFactory('ReentrantClaimer');
+      winnerA = await factory.deploy();
+      winnerB = await getWalletWithEthers();
+      snapshot = await helpers.takeSnapshot();
+    });
+    after(async () => {
+      await snapshot.restore();
+    });
+
+    it('Fund with LINK', async () => {
+      await (await link.mint(manager.address, ethers.utils.parseEther('100'))).wait();
+    });
+
+    it('Create 2 ETH raffles', async () => {
+      const value = 1;
+      {
+        const tx = await manager.lockETH(
+          counterpartContractAddress,
+          1,
+          100,
+          value,
+          {
+            value
+          }
+        );
+        await tx.wait();
+      }
+      {
+        const tx = await manager.lockETH(
+          counterpartContractAddress,
+          1,
+          101,
+          value,
+          {
+            value
+          }
         );
+        await tx.wait();
+      }
+    });
+    it('Declare 2 different winners for each', async () => {
+      {
+        const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
+          manager.connect(signer).ccipReceive({
+            messageId: ethers.constants.HashZero,
+            sourceChainSelector: 1,
+            sender: '0x' + counterpartContractAddress.slice(-40).padStart(64, '0'),
+            data: '0x' +
+              '01' +
+              '0000000000000000000000000000000000000000000000000000000000000064' +
+              winnerA.address.slice(-40).toLowerCase(),
+            destTokenAmounts: []
+          })
+        );
+        await tx.wait();
+      }
+      {
+        const tx = await whileImpersonating(ccipRouter.address, ethers.provider, async (signer) =>
+          manager.connect(signer).ccipReceive({
+            messageId: ethers.constants.HashZero,
+            sourceChainSelector: 1,
+            sender: '0x' + counterpartContractAddress.slice(-40).padStart(64, '0'),
+            data: '0x' +
+              '01' +
+              '0000000000000000000000000000000000000000000000000000000000000065' +
+              winnerB.address.slice(-40).toLowerCase(),
+            destTokenAmounts: []
+          })
+        );
+        await tx.wait();
+      }
+    });
+
+    it('Cannot re-enter and double-claim as Winner A', async () => {
+      await expect(winnerA.doubleClaim(manager.address, 100)).to.be.revertedWithCustomError(
+        manager,
+        'AlreadyClaimed',
+      );
     });
 
     it('Claim as winner B', async () => {
